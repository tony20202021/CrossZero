# -*- coding: utf-8 -*-
"""cross_zero_01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pir41O5sbGfEzktBQsSRr6ZHhHbCotLI

# игра в крестики-нолики
* нейросеть
* обучение:
  * генетический алгоритм
* автоматический подбор:
  * количества нейронов в скрытом слое
  * количества скрытых слоев
"""

# from google.colab import drive
# drive.mount('/content/drive')

# torch/numpy
random_seed_fix = True

"""# импорт"""

!pip install -q pytorch-lightning

# опция -q позволяет значительно уменьшить вывод при установке пакета



import matplotlib.pyplot as plt

import numpy as np
import random
import os
import collections

import tqdm

import torch
print(torch.__version__)

device = torch.device("cuda") if torch.cuda.is_available() else torch.device("cpu")
print(device)

"""### фиксируем генераторы случайных чисел"""

if random_seed_fix:
  
  seed = 12345

  random.seed(seed)
  np.random.seed(seed)

  torch.random.manual_seed(seed)

  torch.cuda.manual_seed(seed)
  torch.cuda.manual_seed_all(seed)

  torch.cuda.deterministic = True
  torch.cuda.benchmark = False

max_threads = 32

os.environ["OMP_NUM_THREADS"] = str(max_threads)
os.environ["OPENBLAS_NUM_THREADS"] = str(max_threads)
os.environ["MKL_NUM_THREADS"] = str(max_threads)
os.environ["VECLIB_MAXIMUM_THREADS"] = str(max_threads)
os.environ["NUMEXPR_NUM_THREADS"] = str(max_threads)

"""# сеть
* вход: тензор 1*9, значения (-1, 0, 1), float
* скрытые слои: 
    * количество слоев - пока 1, попробовать динамическое добавление
    * количество нейронов - начинаем с 2, динамическое добавление
* выход: тензор 1*9, float, вероятности хода в соответствующую ячейку
"""

from common import  NetCurrent

"""## тест"""

cross_zero_net = NetCurrent(hidden_count=2, verbose=True)
print(cross_zero_net)

print(list(cross_zero_net.parameters()))

print(next(cross_zero_net.parameters()).device)

input = torch.Tensor([
         [0, 0, 0],
         [0, 0, 0],
         [0, 0, 0],
]).contiguous().view(-1).type(torch.float)
input.requires_grad = False
input = input.to(device)
print(input)

cross_zero_net.to(device)
output = cross_zero_net(input)
print(output)

"""# игрок
* вход: как у сети (тензор 1*9, float, значения (-1, 0, 1))
* выход: одно число, int - индекс ячейки в вытянутом тензоре 1*9
"""

from common import PlayerRandom

player = PlayerRandom()

input = torch.Tensor([
         [0, 0, 0],
         [0, 0, 0],
         [0, 0, 0],
]).type(torch.float).contiguous().view(-1)
input.requires_grad = False
input = input.to(device)

output = player.make_move(input)
print(output)

from common import PlayerCurrent

"""## тест"""

player = PlayerCurrent(NetCurrent(hidden_count=2, verbose=True))
print(player)

input = torch.Tensor([
         [0, 0, 0],
         [0, 0, 0],
         [0, 0, 0],
]).contiguous().view(-1)
input.requires_grad = False
input = input.to(device)

move = player.make_move(input)
print(move)

from common import Presentation()



from common import PopulationCurrent

"""## тест"""

population = PopulationCurrent(3)
print(population)



from common import Scoring()

"""## тест"""

board = torch.Tensor([
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
]).contiguous().view(-1).type(torch.float)
board = board.to(device)

print(Scoring.is_line(board, FIGURES_TO_VALUES['_X_']), Scoring.is_line(board, FIGURES_TO_VALUES['_0_']))

board = torch.Tensor([
    [1, 1, 1],
    [1, 1, 1],
    [1, 1, 1],
]).contiguous().view(-1).type(torch.float)
board = board.to(device)

print(Scoring.is_line(board, FIGURES_TO_VALUES['_X_']), Scoring.is_line(board, FIGURES_TO_VALUES['_0_']))

board = torch.Tensor([
    [-1, -1, -1],
    [-1, -1, -1],
    [-1, -1, -1],
]).contiguous().view(-1).type(torch.float)
board = board.to(device)

print(Scoring.is_line(board, FIGURES_TO_VALUES['_X_']), Scoring.is_line(board, FIGURES_TO_VALUES['_0_']))

for template in TEMPLATES_WIN:
    print(Scoring.is_line(template, FIGURES_TO_VALUES['_X_']))

from common import PartyCurrent

"""## тест"""

party = PartyCurrent(verbose=True)
print(party)

player_our = PlayerCurrent()
player_enemy = PlayerRandom()

party_result = party.play_party(player_our, player_enemy)
print(party_result)



from common import EvaluatePlayerCurrent

"""## тест"""

evaluate_player = EvaluatePlayerCurrent(num_parties=10
                                        # PARTIES['random']
                                        )
print(evaluate_player)

# evaluate_player.party.verbose = False

player = PlayerCurrent()
print(player)

result = evaluate_player.evaluate(player)
print(result)



"""# вычисление результата популяции"""

from common import EvaluatePopulationCurrent

"""## тест"""

evaluate_population = EvaluatePopulationCurrent(num_parties=100)
print(evaluate_population)

population = PopulationCurrent(10)
print(population)

print(population.players)

evaluate_population.evaluate(population)
print([p.score for p in population.players])



from common import TrainPopulationCurrent

"""## тест"""

train_population = TrainPopulationCurrent(num_parties=10, evaluate_population_class=EvaluatePopulationCurrent, num_epoch=10)
print(train_population)

population = PopulationCurrent(10)
print(population)

print(train_population.train(population))

